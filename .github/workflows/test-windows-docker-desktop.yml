name: Test Windows Docker Desktop

on:
  pull_request:
    paths:
      - "go.*"
      - "pkg/**"
      - "cmd/**"
      - "Makefile"
      - "vendor/**"
      - ".github/workflows/**"
      - "!.github/workflows/docs**"
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Run the build with tmate set "debug_enabled"'
        type: boolean
        required: false
        default: false
      testargs:
        description: 'TESTARGS value'
        type: string
        required: false
        default: '-failfast'
      gotest_short:
        description: 'GOTEST_SHORT value (16=drupal11 only)'
        type: string
        required: false
        default: '16'
      ddev_embargo_tests:
        description: 'Pipe-separated list of test names to skip (e.g., TestName1|TestName2)'
        type: string
        required: false
        default: ''
      make_target:
        description: 'Make target to run'
        type: string
        required: false
        default: 'test'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  GOTEST_SHORT: ${{ inputs.gotest_short || '16' }}
  TESTARGS: ${{ inputs.testargs || '-failfast' }}
  MAKE_TARGET: ${{ inputs.make_target || 'test' }}
  DDEV_EMBARGO_TESTS: ${{ inputs.ddev_embargo_tests || vars.DDEV_EMBARGO_TESTS || '' }}
  DDEV_SKIP_NODEJS_TEST: 'true'
  GO_VERSION: '1.26.0'
  MKCERT_VERSION: 'v1.4.4'

jobs:
  test-windows-docker-desktop:
    runs-on: windows-2025
    timeout-minutes: 240

    name: Windows Docker Desktop

    steps:
      - name: Ensure Git Bash is first in PATH
        shell: pwsh
        run: |
          # GITHUB_PATH entries are prepended to PATH for subsequent steps
          "C:\Program Files\Git\usr\bin" | Out-File -Append -Encoding utf8 $env:GITHUB_PATH
          "C:\Program Files\Git\bin" | Out-File -Append -Encoding utf8 $env:GITHUB_PATH

      - name: Create non-admin testuser
        shell: pwsh
        run: |
          Write-Host "Creating standard (non-admin) testuser"
          net user testuser Password1! /add /y
          # Add to docker-users if the group exists (Docker Desktop creates it)
          try { net localgroup docker-users testuser /add 2>&1 } catch {}
          if ($LASTEXITCODE -ne 0) { Write-Host "docker-users group not found (expected with Moby)" }
          # Verify testuser is NOT in Administrators
          $groups = net user testuser | Select-String "Local Group Memberships"
          Write-Host "testuser group memberships: $groups"
          Write-Host "testuser created successfully"

      - name: Create shared temp directory
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path "C:\ddev-ci-tmp" | Out-Null
          icacls "C:\ddev-ci-tmp" /grant "Everyone:(OI)(CI)F" /T /Q

      - name: Install PsExec
        shell: pwsh
        run: |
          $psexecDir = "$env:USERPROFILE\pstools"
          New-Item -ItemType Directory -Force -Path $psexecDir | Out-Null
          Write-Host "Downloading PsTools..."
          Invoke-WebRequest -Uri "https://download.sysinternals.com/files/PSTools.zip" -OutFile "$psexecDir\PSTools.zip"
          Expand-Archive -Path "$psexecDir\PSTools.zip" -DestinationPath $psexecDir -Force
          "$psexecDir" | Out-File -Append -Encoding utf8 $env:GITHUB_PATH
          Write-Host "PsExec installed to $psexecDir"
          # Pre-accept the EULA via registry for both admin and testuser
          reg add "HKCU\Software\Sysinternals\PsExec" /v EulaAccepted /t REG_DWORD /d 1 /f
          reg add "HKU\.DEFAULT\Software\Sysinternals\PsExec" /v EulaAccepted /t REG_DWORD /d 1 /f

      - name: Install WSL2 distribution as testuser
        shell: pwsh
        run: |
          # WSL distros are per-user, so install as testuser via PsExec.
          # Run wsl.exe directly (not through cmd /c) to avoid quoting issues.
          $wsl = "C:\Windows\System32\wsl.exe"
          Write-Host "Setting WSL default version to 2"
          wsl --set-default-version 2
          Write-Host "Installing DDEV Ubuntu distro as testuser"
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl --install --name DDEV --no-launch
          # Write the distro setup commands to a script to avoid nested quoting
          $script = @'
          #!/usr/bin/env bash
          set -eu -o pipefail
          set -x
          useradd -m -s /bin/bash testuser
          echo 'testuser:password' | chpasswd
          usermod -aG sudo testuser
          printf '[boot]\nsystemd=true\n\n[user]\ndefault=testuser\n' > /etc/wsl.conf
          '@
          $script = $script -replace "`r`n", "`n"
          [System.IO.File]::WriteAllText("C:\ddev-ci-tmp\setup-wsl-distro.sh", $script)
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl -d DDEV --user root bash -e /mnt/c/ddev-ci-tmp/setup-wsl-distro.sh
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl --set-default DDEV
          Write-Host "Verifying WSL installation"
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl --list --verbose

      - name: Restart WSL to enable systemd
        shell: pwsh
        run: |
          $wsl = "C:\Windows\System32\wsl.exe"
          Write-Host "Shutting down WSL so systemd and default user take effect"
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl --shutdown
          Start-Sleep -Seconds 5
          Write-Host "Verifying WSL comes back with correct user"
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl whoami
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl -- uname -a
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl -- systemctl is-system-running --wait

      - name: Install Docker CLI in WSL2
        shell: pwsh
        run: |
          $wsl = "C:\Windows\System32\wsl.exe"
          # Write script with Unix line endings to avoid \r issues when pwsh passes to WSL
          $script = @'
          #!/usr/bin/env bash
          set -eu -o pipefail
          set -x
          export DEBIAN_FRONTEND=noninteractive
          apt-get update -qq >/dev/null
          apt-get install -qq -y ca-certificates curl gnupg >/dev/null
          install -m 0755 -d /etc/apt/keyrings
          rm -f /etc/apt/keyrings/docker.gpg
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
          chmod a+r /etc/apt/keyrings/docker.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list >/dev/null
          apt-get update -qq >/dev/null
          apt-get install -qq -y docker-ce-cli docker-compose-plugin >/dev/null
          echo "Docker CLI installed:"
          docker --version
          '@
          $script = $script -replace "`r`n", "`n"
          [System.IO.File]::WriteAllText("C:\ddev-ci-tmp\install-docker-cli.sh", $script)
          # Run as testuser who owns the WSL distro, but use root inside WSL for apt
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl -u root -- bash -e /mnt/c/ddev-ci-tmp/install-docker-cli.sh
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      - name: Expose Docker to WSL2 via TCP
        shell: pwsh
        run: |
          # The runner uses Moby/Docker CE, not Docker Desktop.
          # Configure dockerd to also listen on TCP so WSL2 can reach it.
          # This is safe in CI since the runner is ephemeral and not exposed externally.
          Write-Host "Configuring Docker daemon to listen on TCP port 2375..."
          $daemonJson = "C:\ProgramData\docker\config\daemon.json"
          $config = @{}
          if (Test-Path $daemonJson) {
            $config = Get-Content $daemonJson -Raw | ConvertFrom-Json -AsHashtable
          } else {
            New-Item -ItemType Directory -Force -Path (Split-Path $daemonJson) | Out-Null
          }
          # Add TCP listener alongside the existing named pipe
          $config["hosts"] = @("npipe://", "tcp://0.0.0.0:2375")
          $config | ConvertTo-Json -Depth 10 | Set-Content $daemonJson
          Write-Host "daemon.json:"
          Get-Content $daemonJson

          # Allow WSL2 to reach Docker on TCP 2375 through Windows Firewall
          Write-Host "Adding firewall rule for Docker TCP access from WSL2..."
          New-NetFirewallRule -DisplayName "Docker daemon TCP 2375" `
            -Direction Inbound -Action Allow -Protocol TCP -LocalPort 2375

          Write-Host "Restarting Docker service..."
          Restart-Service docker
          # Wait for Docker to be ready
          $timeout = 60
          $elapsed = 0
          while ($elapsed -lt $timeout) {
            try {
              $null = docker ps 2>&1
              if ($LASTEXITCODE -eq 0) {
                Write-Host "Docker is ready after ${elapsed}s"
                break
              }
            } catch {}
            Start-Sleep -Seconds 5
            $elapsed += 5
            Write-Host "Waiting for Docker... ${elapsed}s"
          }
          if ($elapsed -ge $timeout) {
            Write-Error "Docker did not become ready within ${timeout}s"
            exit 1
          }

      - name: Configure WSL2 Docker access and verify
        shell: pwsh
        run: |
          $wsl = "C:\Windows\System32\wsl.exe"
          # Set DOCKER_HOST in testuser's profile so docker CLI in WSL2 connects
          # to the Windows host's dockerd over TCP.
          # With WSL2 NAT networking, the Windows host is reachable via the default gateway.
          $script = @'
          #!/usr/bin/env bash
          set -eu -o pipefail
          set -x
          # Get the Windows host IP (default gateway from WSL2 perspective)
          WIN_HOST=$(ip route show default | awk '{print $3}')
          echo "Windows host IP from WSL2: $WIN_HOST"
          # Configure DOCKER_HOST for testuser
          echo "export DOCKER_HOST=tcp://${WIN_HOST}:2375" >> /home/testuser/.bashrc
          echo "export DOCKER_HOST=tcp://${WIN_HOST}:2375" >> /home/testuser/.profile
          # Verify connectivity
          export DOCKER_HOST="tcp://${WIN_HOST}:2375"
          docker version
          docker info
          '@
          $script = $script -replace "`r`n", "`n"
          [System.IO.File]::WriteAllText("C:\ddev-ci-tmp\configure-docker-wsl.sh", $script)
          PsExec.exe -accepteula -u testuser -p Password1! -w "C:\" $wsl -u root -- bash -e /mnt/c/ddev-ci-tmp/configure-docker-wsl.sh
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Grant testuser access to workspace
        shell: pwsh
        run: |
          # Give testuser full access to the checkout directory
          icacls "${{ github.workspace }}" /grant "testuser:(OI)(CI)F" /T /Q
          # Also grant access to the Go installation and USERPROFILE for Go cache
          $goRoot = (go env GOROOT)
          icacls "$goRoot" /grant "testuser:(OI)(CI)RX" /T /Q
          # Grant access to Go cache/module paths
          icacls "$env:USERPROFILE" /grant "testuser:(OI)(CI)F" /T /Q
          # Create testuser home directory and GOPATH
          $testUserHome = "C:\Users\testuser"
          New-Item -ItemType Directory -Force -Path "$testUserHome\go" | Out-Null
          icacls "$testUserHome" /grant "testuser:(OI)(CI)F" /T /Q

#      - name: Install mkcert
#        shell: pwsh
#        run: |
#          $mkcertUrl = "https://github.com/FiloSottile/mkcert/releases/download/${{ env.MKCERT_VERSION }}/mkcert-${{ env.MKCERT_VERSION }}-windows-amd64.exe"
#          $mkcertPath = "$env:USERPROFILE\bin\mkcert.exe"
#          New-Item -ItemType Directory -Force -Path "$env:USERPROFILE\bin" | Out-Null
#          Write-Host "Downloading mkcert from $mkcertUrl"
#          Invoke-WebRequest -Uri $mkcertUrl -OutFile $mkcertPath
#          echo "$env:USERPROFILE\bin" | Out-File -Append -Encoding utf8 $env:GITHUB_PATH
#          Write-Host "Installing mkcert CA"
#          & $mkcertPath -install

      - name: Install NSIS for Windows installer tests
        shell: pwsh
        run: |
          choco install -y nsis gsudo
          # Refresh PATH so gsudo and makensis are available
          Import-Module "$env:ChocolateyInstall\helpers\chocolateyProfile.psm1"
          refreshenv
          # Set up NSIS plugins needed for the DDEV installer
          & "C:\Program Files\Git\bin\bash.exe" -c 'bash .ci-scripts/nsis_setup.sh "/c/Program Files (x86)/NSIS"'

      - name: Show test configuration
        shell: pwsh
        run: |
          Write-Host "=== Test Configuration ==="
          Write-Host "GOTEST_SHORT: ${{ env.GOTEST_SHORT }}"
          Write-Host "TESTARGS: ${{ env.TESTARGS }}"
          Write-Host "MAKE_TARGET: ${{ env.MAKE_TARGET }}"
          Write-Host ""
          Write-Host "=== Windows Host ==="
          Write-Host "Architecture: $env:PROCESSOR_ARCHITECTURE"
          Write-Host "OS: $((Get-CimInstance Win32_OperatingSystem).Caption)"
          Write-Host "Runner: ${{ runner.os }} / ${{ runner.arch }}"
          Write-Host ""
          Write-Host "=== Go ==="
          go version
          Write-Host ""
          Write-Host "=== Docker ==="
          docker version
          Write-Host ""
          Write-Host "=== Git ==="
          git --version
          git describe --tags --always

      - name: Build DDEV as testuser
        shell: pwsh
        run: |
          $goRoot = (go env GOROOT)
          $workspace = "${{ github.workspace }}"
          # Write a build script to avoid PsExec/bash quoting issues
          $buildScript = @"
          #!/usr/bin/env bash
          set -eu -o pipefail
          set -x
          export PATH="$goRoot/bin:`$PATH"
          cd "$workspace"
          make
          "@
          $buildScript = $buildScript -replace "`r`n", "`n"
          [System.IO.File]::WriteAllText("C:\ddev-ci-tmp\build-ddev.sh", $buildScript)
          # Run bash script as testuser via PsExec
          # -accepteula: auto-accept EULA, -u/-p: run as testuser
          # -w: working directory, -e: use current environment
          PsExec.exe -accepteula -u testuser -p Password1! -w "$workspace" -e "C:\Program Files\Git\bin\bash.exe" --login "C:\ddev-ci-tmp\build-ddev.sh"
          if ($LASTEXITCODE -ne 0) { exit $LASTEXITCODE }

      - name: Setup tmate session
        if: ${{ inputs.debug_enabled }}
        uses: mxschmitt/action-tmate@v3
        with:
          limit-access-to-actor: true

# Uncomment when ready to run tests
#      - name: Run Windows installer tests
#        shell: bash
#        env:
#          DDEV_TEST_USE_REAL_INSTALLER: 'true'
#          DDEV_NO_INSTRUMENTATION: 'true'
#          DDEV_NONINTERACTIVE: 'true'
#          DDEV_DEBUG: 'true'
#        run: |
#          make testwininstaller TESTARGS="-failfast"
#
#      - name: Run DDEV tests
#        shell: bash
#        env:
#          GOTEST_SHORT: ${{ env.GOTEST_SHORT }}
#          DDEV_NO_INSTRUMENTATION: 'true'
#          DDEV_NONINTERACTIVE: 'true'
#          DDEV_DEBUG: 'true'
#          DDEV_SKIP_NODEJS_TEST: 'true'
#          DDEV_EMBARGO_TESTS: ${{ env.DDEV_EMBARGO_TESTS }}
#          DOCKER_SCAN_SUGGEST: 'false'
#          DOCKER_SCOUT_SUGGEST: 'false'
#          BUILDKIT_PROGRESS: plain
#        run: |
#          make ${{ env.MAKE_TARGET }} TESTARGS="${{ env.TESTARGS }}"
#          ddev poweroff || true
